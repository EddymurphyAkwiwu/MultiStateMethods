colnames(data_added_rows) <- colnames(hold)
rownames(data_added_rows) <- NULL
data.hmm = data_added_rows
bayestsm_dat = data.hmm
temp_data = as.matrix(bayestsm_dat); rownames(temp_data) = NULL
id = temp_data[, "id"]
y  = temp_data[, "state"]
x  = temp_data[, c("Z.1", "Z.2"), drop=F]
tt  = temp_data[, "time"]
disc_t = rep(-1, length(tt))
disc_t = temp_data[,"disc_time"]
out=list()
for(l in 1:n.chains){
init_par = c(-3-2*runif(1), 0, 0, 0, # beta(0, x), beta(1, x), beta(2, x), beta(2, x_time)
-3+runif(1), 0, 0, 0) # beta(0, t), beta(1, t), beta(2, t), beta(2, t_time)
mcmc_chain = mcmc_routine(y, x, tt, id, init_par, prior_par, par_index,
steps, burnin, disc, disc_t)
out[[l]]=  list(chain = mcmc_chain$chain, accept = mcmc_chain$accept)
}
mcmc.par = list()
mcmc.par.all = mcmc.par.all.est =  matrix()
accept.rate = NA
mat = list()
for(j in 1: length(out) ){
chain = out[[j]]$chain
chain.all = out[[j]]$chain
mcmc.par[[j]] = mcmc(chain)
accept.rate[j] = out[[j]]$accept
#############################
chain2 = chain
colnames(chain2) = paste('pr',1:ncol(chain2), sep = '')
mat[[j]] = chain2
#############################
if(j==1){
mcmc.par.all = chain
mcmc.par.all.est  = chain.all
}else{
mcmc.par.all = rbind(mcmc.par.all, chain)
mcmc.par.all.est = rbind(mcmc.par.all.est, chain.all)
}
}
accept.rate
par.mcmc.list = mcmc.list(mcmc.par)
myData = bayestsm_dat
QQ <- function(x_ik,beta){
betaMat = matrix(beta, ncol = 4, byrow = T)
q_x  = exp(c(1,x_ik) %*% betaMat[1,])  # Transition from state 1 to state 2
q_t  = exp(c(1,x_ik) %*% betaMat[2,])  # Transition from state 2 to state 3
qmat = matrix(c( 0,q_x,  0,
0,  0,q_t,
0,  0,  0), nrow=3, byrow = T)
diag(qmat) = -rowSums(qmat)
return(qmat)
}
prob_evolution_expm <- function(state_from, state_to, z1, z2, par) {
t_seq = NULL
if(state_to == 2) {
t_seq = t.x
} else {
t_seq = t.y
}
probEvo = rep(NA,length(t_seq))
P = rep(0,3)
P[state_from] = 1
index = 1
for(t in 2:length(t_seq)) {
beta = par
# Q_mat = Q(c(z1, z2, t_seq[t-1]), par)
Q_mat = QQ(c(z1, z2, floor(t_seq[t-1])), par)
new_P = expm((t_seq[t] - t_seq[t-1]) * Q_mat, method = 'Pade')
P = P %*% new_P
if(state_to == 2) {
probEvo[index] = P[state_to] + P[state_to+1]
} else {
probEvo[index] = P[state_to]
}
index = index + 1
}
return(probEvo[-lx])
}
#
unique_ids = 1:n
cdf.x =  matrix(nrow =n, ncol = length(t.x)-1)
cdf.y = matrix(nrow =n, ncol = length(t.y)-1)
compute.cdf = function(para){
par = para
# par = mcmc.samples[para,]
for(i in 1:nrow(cdf.x)) {
# print(i)
subDat = myData[myData[,'id'] == unique_ids[i], ]
z_1 = subDat[1,'Z.1']
z_2 = subDat[1,'Z.2']
cdf.x[i,] = prob_evolution_expm(1, 2, z_1, z_2, par)
cdf.y[i,] = prob_evolution_expm(2, 3, z_1, z_2, par)
}
cdx = colMeans(cdf.x)
cdy = colMeans(cdf.y)
return(c(cdx,cdy))
}
mcmc.samples = mcmc.par.all.est[sample(1:nrow(mcmc.par.all.est),n.post.samples),]
cdf.all = apply(mcmc.samples,1,compute.cdf)
p.x = rbind(0,cdf.all[1:((dim(cdf.all )[1])/2),])
p.y = rbind(0,cdf.all[(((dim(cdf.all )[1])/2)+1): dim(cdf.all )[1],])
#
cdf.x.med = apply(p.x,1,median,na.rm=T)
cdf.x.Lower = apply(p.x,1,quantile, c(0.025, 0.975),na.rm=T)[1,]
cdf.x.Upper = apply(p.x,1,quantile, c(0.025, 0.975),na.rm=T)[2,]
cdf.y.med = apply(p.y,1,median,na.rm=T)
cdf.y.Lower = apply(p.y,1,quantile, c(0.025, 0.975),na.rm=T)[1,]
cdf.y.Upper = apply(p.y,1,quantile, c(0.025, 0.975),na.rm=T)[2,]
est.x  = cdf.x.med
est.y  = cdf.y.med
plot(t.x,est.x,type="l",col=1,lty=1,lwd=2,ylim=c(0,1),
xlab="time since entry in state 1",ylab="CDF",
main = "Transition from state 1 to 2")
lines(t.x,TrueX,type="l",lwd=2,col='blue',lty=2)
legend("bottomright", legend=c("Model Estimate", "True"),
col=c("black", "blue"), lty=c(1, 2), lwd=2)
plot(t.y,est.y,type="l",col=1,lty=1,lwd=2,ylim=c(0,1),
xlab="time since entry in state 2",ylab="CDF",
main = "Transition from state 2 to 3")
lines(t.y,TrueY,type="l",lwd=2,col='blue',lty=2)
setwd("C:/Users/akwiw/surfdrive/Desktop/PhD Work/Project_4/Simulations/Final/Exponential_dist/jack-Exp")
setwd("C:/Users/akwiw/surfdrive/Desktop/PhD Work/Project_4/Simulations/Final/Exponential_dist/jack-Exp")
rm(list = ls())
# rm(list = ls())
library(doParallel)
library(MCMCpack)
library(coda)
library(mvtnorm)
library(MHadaptive)
library(mcmcr)
library(MASS)
library(MCMCpack)
library(mvtnorm)
library(actuar)
library(tidyverse)
# set.seed(1)
# start_time =  proc.time()   # Start timing
# We source startup.r which loads all required functions
source('controllers/startup.r')
##################   Without  covariate ##########
# set.seed(022021)
# n = 1000  # Sample size
n = 2000  # Sample size
p = 0 # number of covariates
p.discrete = 0
r=.1
s = 1
beta.X  = c(0.5,0.5)
beta.S  = c(0.5,0.5)
sigma.X = 1         # True scale parameter
mu.X    = 3           # True intercept parameter
sigma.S = 1        # True scale parameter
mu.S    = 1.2           # True intercept parameters
cor.X.S = 0
dist.X='weibull'
dist.S='weibull'
#####  Strong censoring ###########
#
v.min   = 1           # Minimum time between screening moments
v.max   = 3           # Maximum time between screening moments
Tmax    = 2e2        # Maximum number of screening times (this is set to high value; but too high values increase computation time)
mean.rc = 14
do.b.XS = F; b.XS = NULL
#####  Medium censoring ###########
# v.min   = 1           # Minimum time between screening moments
# v.max   = 3.8          # Maximum time between screening moments
# Tmax    = 2e2        # Maximum number of screening times (this is set to high value; but too high values increase computation time)
# mean.rc = 36.5
# do.b.XS = F; b.XS = NULL
if(p ==0){
beta.X = as.matrix(mu.X)
beta.S = as.matrix(mu.S)
}   else{
beta.X = as.matrix(c(mu.X, beta.X))
beta.S = as.matrix(c(mu.S, beta.S))
}
# Sim Z
R = matrix(r, p, p)
diag(R) =  1
S = rep(s, p)
Sigma = cor2cov(R, S)
if(p>0) {Z = mvrnorm(n, mu = rep(0,p), Sigma)} else Z = NULL
# Sim discrete Z
if(p.discrete == 1){
Z.discrete = rbinom(n, 1, 0.5)
Z = cbind( Z, Z.discrete)
colnames(Z) = paste(1:ncol(Z))
}
Z1 = cbind( as.matrix(rep(1,n)),Z)
# Sim.X
if( dist.X=='weibull' | dist.X=='loglog' | dist.X=='lognormal' ){
if(dist.X=='weibull')    e.X = r.ev(n)
if(dist.X=='loglog')     e.X = rlog(n)
if(dist.X=='lognormal')  e.X = rnorm(n)
X = Z1 %*% beta.X + sigma.X * e.X # log surv times
X = exp(X) # surv times
X  = as.numeric(X)
}
# Sim.S
if( dist.S=='weibull' | dist.S=='loglog' | dist.S=='lognormal' ){
if(dist.S=='weibull')   e.S = r.ev(n)
if(dist.S=='loglog')    e.S = rlog(n)
if(dist.S=='lognormal') e.S = rnorm(n)
S = Z1 %*% beta.S + sigma.S * e.S # log surv times
if(do.b.XS){
#logstdX = scale(X)
S = Z1 %*% beta.S + b.XS * log(X) + sigma.S * e.S # log surv times
}
S = exp(S) # surv times
S = as.numeric(S)
}
if(dist.X=='bv-lognormal'){
Sigma.e  = matrix( c(1, cor.X.S, cor.X.S, 1), 2, 2)
e = mvrnorm(n, c(0,0), Sigma.e)
X = Z1 %*% rbind(mu.X, beta.X) + sigma.X * e[,1] # log surv times
S = Z1 %*% rbind(mu.S, beta.S) + sigma.S * e[,2] # log surv times
X = as.numeric(exp(X))
S = as.numeric(exp(S))
}
# Create total time
XS = as.numeric(X+S)  # Total time from baseline to event 2
# Generate screening sequences
t.rc = rexp(n, 1/mean.rc ) #runif(n, start.rc, vmax*(visitdist+leniancy))
V = as.matrix(runif(n, v.min, v.max ))
for(i in 2:Tmax){
V = cbind(V, runif(n, V[,(i-1)]+v.min, V[,(i-1)]+v.max ))
}
rc = (V >= t.rc) * matrix( rep(t.rc, Tmax), ncol = Tmax, nrow = n)
V  = (V < t.rc) * V + rc
visits2 = V
V  = cbind(0, V)
# V
# Find indices of events
ind.h  = rowSums(V < X) # Last healthy time index
ind.x  = ind.h+1        # First stage 1
ind.xs = rowSums(V < XS) + 1 # First stage 2
ind.x[ind.x>ncol(V)] = ncol(V)
# Define delta (event)
d = rep(-99,n)
d[ind.x < ind.xs ]  = 2
d[ind.x == ind.xs  & ind.xs != (ncol(V)+1)] = 3
d[ind.h == ind.x]  = 1
# Define left and right interval bound
L = V[ cbind(1:nrow(V), ind.h) ]
R = V[ cbind(1:nrow(V), ind.x) ]
R[ ind.h == ind.x ] = Inf
if(p>0) dat = data.frame(L=L, R=R, d=d, X=X, S=S, Z=Z)
if(p==0) dat = data.frame(L=L, R=R, d=d, X=X, S=S)
#
#
# head(dat)
# prop.est = as.numeric(prop.table(table(dat$d)))
# print(prop.table(table(dat$d)))
#
time = state = firstobs= numeric()
copy = NULL
i =1
x = matrix(NA, ncol= 4+length(copy), nrow = 1)
for(i in 1:nrow(dat)){
time = numeric()
state = numeric()
firstobs= numeric()
dd = dat$d
if(dd[i] == 1){
ns = length(unique(V[ i, 1: ind.x[i] ]))
time[1:ns] = unique(V[ i, 1: ind.x[i] ])
state[1:ns] = rep(1,ns)
firstobs[1:ns] = rep(0,ns)
firstobs[1] = 1
}
if(dd[i] == 2){
ns = length(V[ i, 1: ind.x[i] ])
time[1:ns] = unique(V[ i, 1: ind.x[i] ])
state[1:ns] = rep(1,ns)
state[ns] = 2
firstobs[1:ns] = rep(0,ns)
firstobs[1] = 1
}
if(dd[i] == 3){
ns = length(V[ i, 1: ind.x[i] ])
time[1:ns] = unique(V[ i, 1: ind.x[i] ])
state[1:ns] = rep(1,ns)
state[ns] = 3
firstobs[1:ns] = rep(0,ns)
firstobs[1] = 1
}
x.t = cbind(i, time, state, firstobs)
x.t = cbind(x.t, matrix( rep( as.matrix(dat[i,copy]), dim(x.t)[1]), nrow = dim(x.t)[1], ncol =length(copy), T))
x = rbind(x, x.t)
}
x = x[-1,]
# data = data.frame( id = x[,1], state = x[,3],time = x[,2],  firstobs = x[,4] )
data = data.frame( id = x[,1] ,time = x[,2], state = x[,3] )
# head(data)
# save(data,  file = "data.RData")
head(data)
save(data,  file = "data.RData")
setwd("C:/Users/akwiw/surfdrive/Desktop/PhD Work/Project_4/Simulations/Final/Submission_codes/Proof_of_CDF")
rm(list = ls())
library(msm)
load('data.RData')   # load data
# We can look at the observed transitions
statetable.msm(state = state, subject = id, data = data)
head(data)
# Speciify the underlying model using the transition (rate) intensity matrix
Q = rbind ( c( 0, 0.01, 0 ),
c( 0, 0, 0.01 ),
c( 0, 0, 0 ))
#  Fit model
msm.mod = msm( state ~ time, subject = id, data = data, qmatrix = Q)
load('ExpTrueCDF_SCen_p_0.RData') # Assumed true CDF simulated in a large population setting
#
# # The code below describes 3 ways of computing the the cumulative distribution function (CDF)
# #
#
# Graphical demonstration of the equivalence is shown also
#
# # See definition of first passage probability at  help(ppass.msm) of the msm package.
#
#
rm(list = ls())
library(msm)
load('data.RData')   # load data
head(data)
# We can look at the observed transitions
statetable.msm(state = state, subject = id, data = data)
###  First fit a simple markov model (no covariates) with 3 health states as follows:
# Speciify the underlying model using the transition (rate) intensity matrix
Q = rbind ( c( 0, 0.01, 0 ),
c( 0, 0, 0.01 ),
c( 0, 0, 0 ))
# The starting values are set at 0.01. This can be changed/adjusted
#  Fit model
msm.mod = msm( state ~ time, subject = id, data = data, qmatrix = Q)
### Note we compute the CDF for the 3 approaches at time t = 3 as an example.
## Method 1: Uisng the first passage probability function (i.e., ppass.msm function) in msm package directly.
# See section 3.7 of  https://chjackson.github.io/msm/msmcourse/outputs.html#passage-probabilities
CDF.method_one =  ppass.msm(msm.mod, tot=3)  # at time t = 3
#  CDF from state 1 to state 2 is
CDF.method_one[1,2]
# CDF from state 2 to state 3 is
CDF.method_one[2,3]
## Method 2: Using the  estimated transition intensity (or rate) matrix. See help(ppass.msm) of the msm package and section 7.1.1 of the cthmn package manual by Lange et (2013)
# Step 1:  First compute and extract the estimated transition intensity matrix Q.est
Q.est = qmatrix.msm(msm.mod)[[1]]  #  Note [[1]] extracts only the estimates without the corresponding 95% CIs
# Step 2: The sojourn time in state A has the same distribution as time to absorption in a process that
#         starts in state A and treats state B as an absorbing state. Thus, we need to construct a new transition intensity matrix
#         from the original transition intensity matrix Q.est by setting the rows of the original matrix to zero for the state
#         corresponding to the  state B.
#  For example, to find the time distribution from state 1 to state 2 in the model, we set the second row of the original transition intensity matrix Q.est,
#  which corresponds to state 2, to zero. See below
Q.est.new = matrix(nrow=3,ncol=3)   # define new transition intensity matrix
Q.est.new[,] = Q.est   # Extract the original estimated transition intensity matrix Q.est
Q.est.new[2,] = 0  # set 2nd row of the original matrix intensity to zero
# Step 3: Compute the transition probability (i..e, matrix exponential, Exp(tQ) ) using the new transition intensity matrix Q.est.new at time, say t = 3
library(expm)  # load matrix exponential package
CDF.method_two = expm(Q.est.new*3)  # Compute the transition probability at time t = 3
#  CDF from state 1 to state 2 is
CDF.method_two[1,2]
# To estimate the time distribution from state 2 to state 3, repeat the above process but instead set the third row of the original transition intensity matrix
#  to zero. See below:
Q.est.new = matrix(nrow=3,ncol=3)   # define new transition intensity matrix
Q.est.new[,] = Q.est
Q.est.new[3,] = 0  # set 3rd row of the original matrix intensity to zero
CDF.method_two = expm(Q.est.new*3)  #  Compute the transition probability at time t = 3
#  CDF from state 2 to state 3 is
CDF.method_two[2,3]
## Method 3: Directly from the estimated transition probability matrix (see section 3.7 of
#   https://chjackson.github.io/msm/msmcourse/outputs.html#passage-probabilities)
CDF.method_third  = pmatrix.msm(msm.mod, t=3)
#  CDF from state 1 to state 2 is:
CDF.method_third[1,2]  + CDF.method_third[1,3]
#  CDF from state 2 to state 3 is
CDF.method_third[2,3]
load('ExpTrueCDF_SCen_p_0.RData') # Assumed true CDF simulated in a large population setting
##  define time points
t.x = seq(0, 100, length.out=100)
t.y =  seq(0, 20, length.out=100)
F1 = ecdf(dat$X)
F2 = ecdf(dat$S)
# t.x = quantile(dat$X, seq(0, 0.99, 0.01)) %>% as.numeric()
#
# t.y = quantile(dat$S, seq(0, 0.99, 0.01))  %>% as.numeric()
TrueX = F1(t.x)
TrueY = F2(t.y)
cdf.x =  cdf.y = numeric()  # create an empty vector to store cdfs
# Obtain estimated cfds
for(i in 1: length(t.x)){
prob.x       = pmatrix.msm(msm.mod, t=t.x[i])
prob.y       = pmatrix.msm(msm.mod, t=t.y[i])
cdf.x[i] = prob.x[1,2] + prob.x[1,3] # state 1 to state 2
cdf.y[i] = prob.y[2,3]               # state 2 to state 3
}
#  Plot estimated cdfs and true empirical cdfs
###  State 1 to 2
plot(t.x,est.x,type="l",col=1,lty=1,lwd=2,ylim=c(0,1),
xlab="time since entry in state 1",ylab="CDF",
main = "Transition from state 1 to 2")
lines(t.x,TrueX,type="l",lwd=2,col='blue',lty=2) # True empirical CDF (data)
legend("bottomright", legend=c("Model Estimate", "True"),
col=c("black", "blue"), lty=c(1, 2), lwd=2)
###  State 2 to 3
plot(t.y,est.y,type="l",col=1,lty=1,lwd=2,ylim=c(0,1),
xlab="time since entry in state 2",ylab="CDF",
main = "Transition from state 2 to 3")
lines(t.y,TrueY,type="l",lwd=2,col='blue',lty=2) # True empirical CDF (data)
legend("bottomright", legend=c("Model Estimate", "True"),
col=c("black", "blue"), lty=c(1, 2), lwd=2)
###  State 1 to 2
plot(t.x,cdf.x ,type="l",col=1,lty=1,lwd=2,ylim=c(0,1),
xlab="time since entry in state 1",ylab="CDF",
main = "Transition from state 1 to 2")
lines(t.x,TrueX,type="l",lwd=2,col='blue',lty=2) # True empirical CDF (data)
legend("bottomright", legend=c("Model Estimate", "True"),
col=c("black", "blue"), lty=c(1, 2), lwd=2)
plot(t.y,cdf.y ,type="l",col=1,lty=1,lwd=2,ylim=c(0,1),
xlab="time since entry in state 2",ylab="CDF",
main = "Transition from state 2 to 3")
lines(t.y,TrueY,type="l",lwd=2,col='blue',lty=2) # True empirical CDF (data)
legend("bottomright", legend=c("Model Estimate", "True"),
col=c("black", "blue"), lty=c(1, 2), lwd=2)
# Load necessary libraries and clean environment
rm(list = ls())       # Remove all objects in the environment to start fresh
library(msm)          # Load the msm package for multi-state models
library(expm)         # Load expm package for matrix exponentiation
# Load the data
load('data.RData')    # Data should contain states and subject IDs for the analysis
# Display the first few rows of data to inspect
head(data)
# Display observed transitions between states
# This provides an overview of the observed transitions in the data
statetable.msm(state = state, subject = id, data = data)
# Define a 3-state Markov model with the transition intensity matrix Q
# Here, each entry specifies the transition rates between states
# Note: 0.01 is used as a starting value for non-zero transitions; can be adjusted based on data
Q = rbind(
c(0, 0.01, 0),
c(0, 0, 0.01),
c(0, 0, 0)
)
# Fit the model to the data, assuming transitions occur at time points specified by 'time'
# `state ~ time` specifies that the response variable 'state' changes with 'time' for each subject
msm.mod = msm(state ~ time, subject = id, data = data, qmatrix = Q)
# Example time point for CDF estimation
t = 3
## Method 1: Using the first passage probability function `ppass.msm`
# This computes the CDF directly by calculating the probability of first passage from one state to another.
# Documentation: Refer to help(ppass.msm) in msm package for more details
CDF.method_one = ppass.msm(msm.mod, tot=t)
# Extract the CDF for the transition from state 1 to state 2
CDF.method_one[1, 2]
# Extract the CDF for the transition from state 2 to state 3
CDF.method_one[2, 3]
# Step 1: Extract the estimated transition intensity matrix from the fitted model
Q.est = qmatrix.msm(msm.mod)[[1]]  # [[1]] extracts only the estimated rates, excluding confidence intervals
# Define and modify transition intensity matrix Q.est for state 1 to state 2 transition
Q.est.new = Q.est        # Copy the estimated Q matrix
Q.est.new[2, ] = 0       # Set second row to zero to make state 2 an absorbing state
# Step 3: Compute transition probability matrix at t = 3 using matrix exponential
CDF.method_two = expm(Q.est.new * t)
# Extract CDF for the transition from state 1 to state 2
CDF.method_two[1, 2]
# Repeat process to estimate time distribution from state 2 to state 3
Q.est.new = Q.est         # Reset to original Q matrix
Q.est.new[3, ] = 0        # Set third row to zero to make state 3 an absorbing state
# Compute the CDF at t = 3 for this modified matrix
CDF.method_two = expm(Q.est.new * t)
# Extract CDF for the transition from state 2 to state 3
CDF.method_two[2, 3]
# Compute transition probability matrix directly at t = 3 using pmatrix.msm
CDF.method_third = pmatrix.msm(msm.mod, t=t)
# CDF from state 1 to state 2 is the sum of probabilities reaching either state 2 or state 3 from state 1
CDF.method_third[1, 2] + CDF.method_third[1, 3]
# CDF from state 2 to state 3
CDF.method_third[2, 3]
# Load assumed true CDF data for comparison in a large population setting
load('ExpTrueCDF_SCen_p_0.RData')    # Assumed true CDF for large sample setting
# Define time points for plotting
t.x = seq(0, 100, length.out=100)    # Time for state 1 to state 2 transition
t.y = seq(0, 20, length.out=100)     # Time for state 2 to state 3 transition
# Define empirical cumulative distribution functions from the data
F1 = ecdf(dat$X)                     # Empirical CDF for state 1 to 2 transition
F2 = ecdf(dat$S)                     # Empirical CDF for state 2 to 3 transition
# Generate true CDF values at specified time points
TrueX = F1(t.x)
TrueY = F2(t.y)
# Estimate CDFs using pmatrix.msm for a range of time points
cdf.x = cdf.y = numeric(length(t.x)) # Initialize vectors for storing estimated CDFs
for (i in 1:length(t.x)) {
prob.x = pmatrix.msm(msm.mod, t=t.x[i])
prob.y = pmatrix.msm(msm.mod, t=t.y[i])
cdf.x[i] = prob.x[1, 2] + prob.x[1, 3]  # CDF from state 1 to 2
cdf.y[i] = prob.y[2, 3]                # CDF from state 2 to 3
}
# Plot estimated and true CDFs for state 1 to 2 transition
plot(t.x, cdf.x, type="l", col=1, lty=1, lwd=2, ylim=c(0, 1),
xlab="time since entry in state 1", ylab="CDF",
main="Transition from state 1 to 2")
lines(t.x, TrueX, type="l", lwd=2, col='blue', lty=2)   # True empirical CDF (data)
# Add legend
legend("bottomright", legend=c("Model Estimate", "True"),
col=c("black", "blue"), lty=c(1, 2), lwd=2)
# Plot estimated and true CDFs for state 2 to 3 transition
plot(t.y, cdf.y, type="l", col=1, lty=1, lwd=2, ylim=c(0, 1),
xlab="time since entry in state 2", ylab="CDF",
main="Transition from state 2 to 3")
lines(t.y, TrueY, type="l", lwd=2, col='blue', lty=2)   # True empirical CDF (data)
# Add legend
legend("bottomright", legend=c("Model Estimate", "True"),
col=c("black", "blue"), lty=c(1, 2), lwd=2)
